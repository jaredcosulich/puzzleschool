// Generated by CoffeeScript 1.3.3
var Line, db, requireUser, soma,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Line = require('line').Line;

soma = require('soma');

db = require('../lib/db');

requireUser = require('./lib/decorators').requireUser;

soma.routes({
  '/api/puzzles/:puzzleName': requireUser(function(data) {
    var l,
      _this = this;
    return l = new Line({
      error: function(err) {
        console.log('Loading puzzle data failed:', err);
        return _this.sendError();
      }
    }, function() {
      return db.get('user_puzzles', "" + _this.user.id + "/" + data.puzzleName, l.wait());
    }, function(userPuzzle) {
      _this.userPuzzle = userPuzzle;
      if (!_this.userPuzzle) {
        _this.send({});
        l.stop();
      }
    }, function() {
      return db.multiget('user_puzzle_progress', _this.userPuzzle.levelsPlayed, l.wait());
    }, function(data) {
      var level, _i, _len, _ref;
      _this.userPuzzle.levels = {};
      _ref = data.user_puzzle_progress;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        level = _ref[_i];
        _this.userPuzzle.levels[level.name] = level;
      }
      return delete _this.userPuzzle.levelsPlayed;
    }, function() {
      return _this.send({
        puzzle: _this.userPuzzle
      });
    });
  }),
  '/api/puzzles/:puzzleName/update': requireUser(function(data) {
    var l, levelName, levelUpdate, levelsPlayedUpdates, updates, userPuzzle, _ref, _results,
      _this = this;
    userPuzzle = "" + this.user.id + "/" + data.puzzleName;
    l = new Line({
      error: function(err) {
        console.log('Saving puzzle data failed:', err);
        return _this.sendError();
      }
    }, function() {
      return _this.send();
    });
    if (__indexOf.call(this.user.user_puzzles || [], userPuzzle) < 0) {
      l.add(function() {
        return db.update('users', _this.user.id, {
          user_puzzles: {
            add: [userPuzzle]
          }
        }, l.wait());
      });
    }
    if (this.data.puzzleUpdates) {
      levelsPlayedUpdates = (function() {
        var _ref, _results;
        _ref = this.data.levelUpdates;
        _results = [];
        for (levelName in _ref) {
          updates = _ref[levelName];
          _results.push("" + userPuzzle + "/" + levelName);
        }
        return _results;
      }).call(this);
      if (levelsPlayedUpdates.length) {
        this.data.puzzleUpdates.levelsPlayed = {
          add: levelsPlayedUpdates
        };
      }
      l.add(function() {
        return db.update('user_puzzles', userPuzzle, _this.data.puzzleUpdates, l.wait());
      });
    }
    if (this.data.levelUpdates) {
      _ref = this.data.levelUpdates;
      _results = [];
      for (levelName in _ref) {
        levelUpdate = _ref[levelName];
        levelUpdate.name = levelName;
        _results.push(l.add(function() {
          return db.update('user_puzzle_progress', "" + userPuzzle + "/" + levelName, levelUpdate, l.wait());
        }));
      }
      return _results;
    }
  })
});

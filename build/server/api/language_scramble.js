// Generated by CoffeeScript 1.3.3
var Line, db, requireUser, soma;

Line = require('line').Line;

soma = require('soma');

db = require('../lib/db');

requireUser = require('./lib/decorators').requireUser;

soma.routes({
  '/api/language_scramble/translation/:id': function(_arg) {
    var id, l,
      _this = this;
    id = _arg.id;
    return l = new Line({
      error: function(err) {
        console.log('Error locating translation:', err);
        return _this.sendError();
      }
    }, function() {
      return db.get('language_scramble_translations', id, this.wait());
    }, function(translation) {
      return _this.send(translation);
    });
  },
  '/api/language_scramble/bundles': function() {
    var l,
      _this = this;
    return l = new Line({
      error: function(err) {
        console.log('Error retrieving bundles:', err);
        return _this.sendError();
      }
    }, function() {
      return db.get('language_scramble_translation_lists', 'bundles', this.wait());
    }, function(bundles) {
      return _this.send((bundles != null ? bundles.bundleList : void 0) || []);
    });
  },
  '/api/language_scramble/translations/save': function() {
    var existingTranslation, incompleteUpdates, l, translated, translation, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
      _this = this;
    translation = {};
    if ((_ref = this.data["native"]) != null ? _ref.length : void 0) {
      translation["native"] = this.data["native"];
    }
    if ((_ref1 = this.data.foreign) != null ? _ref1.length : void 0) {
      translation.foreign = this.data.foreign;
    }
    if ((_ref2 = this.data.nativeSentence) != null ? _ref2.length : void 0) {
      translation.nativeSentence = this.data.nativeSentence;
    }
    if ((_ref3 = this.data.foreignSentence) != null ? _ref3.length : void 0) {
      translation.foreignSentence = this.data.foreignSentence;
    }
    l = new Line({
      error: function(err) {
        console.log('Saving translation failed:', err);
        return _this.sendError();
      }
    });
    translated = translation["native"] && translation.foreign;
    incompleteUpdates = {
      noTranslation: {}
    };
    if (!translated) {
      incompleteUpdates.noTranslation.add = [JSON.stringify(translation)];
    } else {
      if (this.data.noTranslation) {
        incompleteUpdates.noTranslation["delete"] = [this.data.noTranslation];
      } else {
        delete incompleteUpdates.noTranslation;
      }
      translation.id = "" + (this.data["native"].replace(/\W/g, '_')) + "-" + (translation.foreign.replace(/\W/g, '_'));
      if ((_ref4 = this.data.bundle) != null ? _ref4.length : void 0) {
        translation.bundle = this.data.bundle;
      }
      if ((_ref5 = this.data.nativeVerificationCount) != null ? _ref5.length : void 0) {
        translation.nativeVerificationCount = this.data.nativeVerificationCount;
      }
      if ((_ref6 = this.data.foreignVerificationCount) != null ? _ref6.length : void 0) {
        translation.foreignVerificationCount = this.data.foreignVerificationCount;
      }
      existingTranslation = null;
      l.add(function() {
        return db.get('language_scramble_translations', translation.id, l.wait());
      });
      l.add(function(existing) {
        existingTranslation = existing || {};
        if (existingTranslation["native"] !== translation["native"] || existingTranslation.nativeSentence !== translation.nativeSentence) {
          translation.nativeVerificationCount = 0;
        }
        if (existingTranslation.foreign !== translation.foreign || existingTranslation.foreignSentence !== translation.foreignSentence) {
          translation.foreignVerificationCount = 0;
        }
        incompleteUpdates.notNativeVerified = {};
        incompleteUpdates.notNativeVerified["" + (translation.nativeVerificationCount ? 'delete' : 'add')] = [translation.id];
        incompleteUpdates.notForeignVerified = {};
        incompleteUpdates.notForeignVerified["" + (translation.foreignVerificationCount ? 'delete' : 'add')] = [translation.id];
        return db.update('language_scramble_translations', translation.id, translation, l.wait());
      });
      l.add(function() {
        var bundleUpdate;
        if (existingTranslation.bundle && existingTranslation.bundle !== translation.bundle) {
          bundleUpdate = {};
          bundleUpdate["" + existingTranslation.bundle] = {
            "delete": [translation.id]
          };
          return db.update('language_scramble_translation_lists', 'bundles', bundleUpdate, l.wait());
        }
      });
      l.add(function() {
        var bundleUpdate;
        if (!translation.bundle) {
          return incompleteUpdates.noBundle = {
            add: [translation.id]
          };
        } else if (existingTranslation.bundle !== translation.bundle) {
          incompleteUpdates.noBundle = {
            "delete": [translation.id]
          };
          bundleUpdate = {};
          bundleUpdate["" + translation.bundle] = {
            add: [translation.id]
          };
          bundleUpdate['bundleList'] = {
            add: [translation.bundle]
          };
          return db.update('language_scramble_translation_lists', 'bundles', bundleUpdate, l.wait());
        }
      });
    }
    l.add(function() {
      return db.update('language_scramble_translation_lists', 'incomplete', incompleteUpdates, l.wait());
    });
    return l.add(function(incompleteStats) {
      return _this.send(incompleteStats);
    });
  },
  '/api/language_scramble/translations/incomplete': function() {
    var l,
      _this = this;
    return l = new Line({
      error: function(err) {
        console.log('Unable to load incomplete translation data:', err);
        return _this.sendError();
      }
    }, function() {
      return db.get('language_scramble_translation_lists', 'incomplete', l.wait());
    }, function(incomplete) {
      return _this.send(incomplete);
    });
  }
});

// Generated by CoffeeScript 1.3.1
var db, decodeId, encodeId, line, riak, riakClient,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

line = require('line');

riak = require('riak-js');

db = exports;

riakClient = new riak.getClient();

encodeId = function(id) {
  return encodeURIComponent(id);
};

decodeId = function(id) {
  return decodeURIComponent(id);
};

db.createTable = function() {};

db.deleteTable = function(table, callback) {
  var stream;
  stream = riakClient.keys(table, {
    keys: 'stream'
  });
  stream.on('keys', function(ids) {
    var id, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = ids.length; _i < _len; _i++) {
      id = ids[_i];
      _results.push((function(id) {
        line(function() {
          return db["delete"](table, id, line.wait());
        });
        return line(function() {
          return setTimeout(line.wait(), 500);
        });
      })(id));
    }
    return _results;
  });
  stream.on('end', function() {
    line.error(callback);
    return line.run(function() {
      return callback(null);
    });
  });
  return stream.start();
};

db.serialize = function(item) {
  var index, key, object, value, _i, _len;
  for (key in item) {
    value = item[key];
    if (Array.isArray(value)) {
      for (index = _i = 0, _len = value.length; _i < _len; index = ++_i) {
        object = value[index];
        if (typeof object !== 'number') {
          value[index] = object.toString();
        }
      }
    } else if (typeof value === 'object') {
      item[key] = value.toString();
    }
  }
  return item;
};

db.nextId = function(table, callback) {
  return riakClient.get('ids', table, function(err, id, meta) {
    if (err) {
      if (err.statusCode === 404) {
        id = 0;
      } else {
        if (err) {
          return callback.apply(this, arguments);
        }
      }
    }
    return riakClient.save('ids', table, (++id).toString(), meta, function(err, meta) {
      if (err) {
        return callback.apply(this, arguments);
      }
      return callback(null, id.toString());
    });
  });
};

db.put = function(table, item, callback) {
  if (item.createdAt == null) {
    item.createdAt = new Date();
  }
  if (item.id) {
    return riakClient.save(table, encodeId(item.id), db.serialize(item), function(err, meta) {
      if (err) {
        return callback.apply(this, arguments);
      }
      return callback(null, item);
    });
  } else {
    return db.nextId(table, function(err, id) {
      if (err) {
        return callback.apply(this, arguments);
      }
      item.id = id;
      return riakClient.save(table, encodeId(item.id), db.serialize(item), function(err, meta) {
        if (err) {
          return callback.apply(this, arguments);
        }
        return callback(null, item);
      });
    });
  }
};

db.get = function(table, id, callback) {
  return riakClient.get(table, encodeId(id), function(err, item, meta) {
    if (err) {
      if (err.statusCode === 404) {
        err = null;
        item = {};
      } else {
        if (err) {
          return callback.apply(this, arguments);
        }
      }
    }
    if (item.id != null) {
      item.id = decodeId(item.id);
    }
    return callback(null, item);
  });
};

db.updateExisting = function(table, id, item, attributes, callback) {
  var el, key, value, _i, _len, _ref;
  for (key in attributes) {
    value = attributes[key];
    if (typeof value === 'object') {
      if (value.add) {
        if (!item[key]) {
          item[key] = (Array.isArray(value.add) ? [] : 0);
        }
        if (Array.isArray(item[key])) {
          _ref = value.add;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            el = _ref[_i];
            if (__indexOf.call(item[key], el) < 0) {
              item[key].push(el);
            }
          }
          attributes[key] = item[key];
        } else if (typeof item[key] === 'number') {
          attributes[key] = item[key] + value.add;
        }
      } else if (value["delete"]) {
        if (Array.isArray(item[key])) {
          attributes[key] = (function() {
            var _j, _len1, _ref1, _results;
            _ref1 = item[key];
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              el = _ref1[_j];
              if (__indexOf.call(value["delete"], el) < 0) {
                _results.push(el);
              }
            }
            return _results;
          })();
        } else if (typeof item[key] === 'number') {
          attributes[key] = item[key] - value["delete"];
        }
      }
    }
  }
  return riakClient.save(table, encodeId(id), db.serialize(attributes), function(err, item, meta) {
    if (err) {
      return callback.apply(this, arguments);
    }
    return db.get(table, id, callback);
  });
};

db.update = function(table, id, attributes, callback) {
  attributes.updatedAt = new Date();
  if ('id' in attributes) {
    if (attributes.id !== id) {
      return callback('Can\'t update id attribute');
    }
  }
  return riakClient.get(table, encodeId(id), function(err, item, meta) {
    if (err) {
      if (err.statusCode === 404) {
        return db.put(table, {
          id: id
        }, function(err, item) {
          if (err) {
            return callback.apply(this, arguments);
          }
          return db.updateExisting(table, id, item, attributes, callback);
        });
      } else {
        if (err) {
          return callback.apply(this, arguments);
        }
      }
    } else {
      return db.updateExisting(table, id, item, attributes, callback);
    }
  });
};

db["delete"] = function(table, id, callback) {
  return riakClient.remove(table, encodeId(id), function(err, item, meta) {
    if (err) {
      return callback.apply(this, arguments);
    }
    return callback(null, item);
  });
};

db.multiget = function(table, ids, callback) {
  var id, results, tables, _fn, _i, _len;
  if (typeof table === 'object') {
    tables = table;
    callback = ids;
  } else {
    tables = {};
    tables[table] = ids;
  }
  results = {};
  for (table in tables) {
    ids = tables[table];
    results[table] = [];
    _fn = function(id) {
      line(function() {
        return db.get(table, id, line.wait());
      });
      return line(function(item) {
        return results[table].push(item);
      });
    };
    for (_i = 0, _len = ids.length; _i < _len; _i++) {
      id = ids[_i];
      _fn(id);
    }
  }
  line.error(callback);
  return line.run(function() {
    callback(null, results);
    return results;
  });
};

// Generated by CoffeeScript 1.3.3
var Equation, EquationComponent, equations;

equations = typeof exports !== "undefined" && exports !== null ? exports : provide('./equations', {});

Equation = require('./equation').Equation;

EquationComponent = require('./equation_component').EquationComponent;

equations.Equations = (function() {

  function Equations(_arg) {
    var submit,
      _this = this;
    this.el = _arg.el, this.gameArea = _arg.gameArea, this.plot = _arg.plot, submit = _arg.submit;
    this.equationsArea = this.$('.equations');
    this.possibleFragments = this.$('.possible_fragments');
    this.equations = [];
    this.$('.launch').bind('click', function() {
      return submit();
    });
  }

  Equations.prototype.$ = function(selector) {
    return $(selector, this.el);
  };

  Equations.prototype.add = function() {
    var equation, equationCount,
      _this = this;
    equationCount = this.equationsArea.find('.equation').length;
    equation = new Equation({
      gameArea: this.gameArea,
      id: "equation_" + (equationCount + 1),
      plot: function(dropArea) {
        return _this.plotFormula(dropArea);
      }
    });
    this.equations.push(equation);
    return equation.appendTo(this.equationsArea);
  };

  Equations.prototype.addComponent = function(equationFragment, equationAreas) {
    var equationComponent,
      _this = this;
    equationComponent = new EquationComponent({
      gameArea: this.gameArea,
      equationFragment: equationFragment,
      equationAreas: equationAreas,
      trackDrag: function(left, top, component) {
        return _this.trackComponentDragging(left, top, component);
      },
      endDrag: function(component) {
        return _this.endComponentDragging(component);
      }
    });
    return equationComponent.appendTo(this.possibleFragments);
  };

  Equations.prototype.trackComponentDragging = function(left, top, component) {
    var equation, x, y, _i, _len, _ref,
      _this = this;
    if (!this.el.hasClass('show_places')) {
      this.el.addClass('show_places');
    }
    x = left + (component.width() / 2);
    y = top + (component.height() / 2);
    this.selectedDropArea = null;
    _ref = this.equations;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      equation = _ref[_i];
      this.selectedDropArea = equation.overlappingDropAreas({
        x: x,
        y: y,
        test: function(dropArea, over) {
          return dropArea != null ? dropArea.highlight(over) : void 0;
        }
      });
      if (this.selectedDropArea) {
        return;
      }
    }
  };

  Equations.prototype.clearDrag = function() {
    var equation, _i, _len, _ref, _results;
    this.el.removeClass('show_places');
    _ref = this.equations;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      equation = _ref[_i];
      _results.push(equation.clear());
    }
    return _results;
  };

  Equations.prototype.endComponentDragging = function(component) {
    var element;
    this.clearDrag();
    if (!this.selectedDropArea) {
      return false;
    }
    element = this.selectedDropArea.element;
    element.addClass('with_component');
    this.selectedDropArea.wrap();
    this.selectedDropArea.component = component;
    if (this.selectedDropArea.parentArea) {
      this.selectedDropArea.parentArea.dirtyCount += 1;
    }
    this.selectedDropArea.format(component);
    this.selectedDropArea.plot();
    this.selectedDropArea.width = this.selectedDropArea.element.width();
    this.selectedDropArea = null;
    return true;
  };

  Equations.prototype.plotFormula = function(dropArea) {
    var formula;
    this.checkMultipleEquations();
    while (dropArea.parentArea) {
      dropArea = dropArea.parentArea;
    }
    dropArea.element.removeClass('bad_formula');
    formula = dropArea.formula();
    if (!(this.plot(dropArea.id, formula) || !formula.length)) {
      return dropArea.element.addClass('bad_formula');
    }
  };

  Equations.prototype.checkMultipleEquations = function() {
    var equation, inUseEquations, _i, _j, _len, _len1, _ref, _ref1, _results;
    inUseEquations = 0;
    _ref = this.equations;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      equation = _ref[_i];
      if (equation.el.html() !== equation.defaultText) {
        inUseEquations += 1;
        if (inUseEquations > 1) {
          break;
        }
      }
    }
    _ref1 = this.equations;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      equation = _ref1[_j];
      if (inUseEquations > 1) {
        _results.push(equation.showRange());
      } else {
        _results.push(equation.hideRange());
      }
    }
    return _results;
  };

  return Equations;

})();

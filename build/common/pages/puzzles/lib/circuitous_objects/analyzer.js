// Generated by CoffeeScript 1.3.3
var analyzer, circuitousObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

analyzer = typeof exports !== "undefined" && exports !== null ? exports : provide('./analyzer', {});

circuitousObject = require('./object');

analyzer.Analyzer = (function(_super) {

  __extends(Analyzer, _super);

  function Analyzer(board) {
    this.board = board;
    this.init();
  }

  Analyzer.prototype.init = function() {
    return this.info = {
      matrix: {},
      node: {},
      sections: {},
      components: {}
    };
  };

  Analyzer.prototype.run = function() {
    var cid, component, componentInfo, sectionId, sectionInfo, _ref, _ref1;
    this.analyze();
    debugger;
    this.createMatrix();
    console.log(this.info.matrix);
    this.solveMatrix();
    componentInfo = {};
    _ref = this.info.matrix.loops[1].sections;
    for (sectionId in _ref) {
      sectionInfo = _ref[sectionId];
      _ref1 = this.info.sections[sectionId].components;
      for (cid in _ref1) {
        component = _ref1[cid];
        componentInfo[cid] = sectionInfo;
      }
    }
    return componentInfo;
  };

  Analyzer.prototype.analyze = function() {
    var cid, component, end, positiveTerminal, start, startKey, startKeys, startNode, startSections, _ref, _results;
    _ref = this.board.components;
    _results = [];
    for (cid in _ref) {
      component = _ref[cid];
      if (!component.voltage) {
        continue;
      }
      if (this.info.components[cid]) {
        continue;
      }
      _results.push((function() {
        var _i, _len, _ref1, _results1;
        _ref1 = component.currentNodes('positive');
        _results1 = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          positiveTerminal = _ref1[_i];
          startNode = this.board.boardPosition(positiveTerminal);
          this.createSections([
            {
              component: component,
              node: startNode
            }
          ]);
          startSections = this.info.node["" + startNode.x + ":" + startNode.y];
          if ((startKeys = Object.keys(startSections)).length === 2) {
            startKey = this.compareNodes(startSections[startKeys[1]].nodes[1], startNode) ? 1 : 0;
            end = startKey === 1 ? startSections[startKeys[0]] : startSections[startKeys[1]];
            start = startSections[startKeys[startKey]];
            _results1.push(this.consumeSection(start, end));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Analyzer.prototype.newSection = function(node) {
    var section;
    section = {
      nodes: [node],
      resistance: 0,
      components: {},
      sections: {},
      id: this.generateId('section')
    };
    return section;
  };

  Analyzer.prototype.createSections = function(sectionInfos) {
    var connections, sectionInfo, _i, _len;
    connections = [];
    for (_i = 0, _len = sectionInfos.length; _i < _len; _i++) {
      sectionInfo = sectionInfos[_i];
      connections = connections.concat(this.createSection(sectionInfo.component, sectionInfo.node));
    }
    if (connections.length) {
      return this.createSections(connections);
    }
  };

  Analyzer.prototype.createSection = function(component, node) {
    var connections, section;
    section = this.newSection(node);
    connections = this.analyzeSection(section, component, this.otherNode(this.boardNodes(component), node));
    this.endSection(section);
    return connections;
  };

  Analyzer.prototype.analyzeSection = function(section, component, node) {
    var connection, connections;
    if (this.addToSection(section, component, node)) {
      connections = this.findConnections(node, section);
      if (connections.length === 1) {
        connection = connections[0];
        return this.analyzeSection(section, connection.component, connection.otherNode);
      } else if (connections.length > 1) {
        return connections;
      }
    }
    return [];
  };

  Analyzer.prototype.addToSection = function(section, component, node) {
    var voltage;
    if (this.info.components[component.id]) {
      return false;
    }
    if (!Object.keys(section.components).length) {
      this.board.color([component.id], 0);
      debugger;
    }
    if (component.voltage) {
      section.direction = (node.negative ? 1 : -1);
      voltage = component.voltage * section.direction;
      section.voltage = (section.voltage || 0) + voltage;
    }
    section.resistance += component.resistance || 0;
    section.components[component.id] = true;
    section.nodes[1] = node;
    this.info.components[component.id] = section.id;
    return true;
  };

  Analyzer.prototype.consumeSection = function(section, sectionToBeConsumed) {
    var cid;
    this.deleteSection(section);
    this.deleteSection(sectionToBeConsumed);
    for (cid in sectionToBeConsumed.components) {
      section.components[cid] = true;
    }
    section.resistance = (section.resistance || 0) + (sectionToBeConsumed.resistance || 0);
    section.voltage = (section.voltage || 0) + (sectionToBeConsumed.voltage || 0);
    section.nodes[1] = sectionToBeConsumed.nodes[1];
    return this.recordSection(section);
  };

  Analyzer.prototype.endSection = function(section) {
    if (!Object.keys(section.components).length) {
      return;
    }
    if (!section.direction) {
      section.direction = 1;
    }
    return this.recordSection(section, component);
  };

  Analyzer.prototype.findConnections = function(node, exceptInSection) {
    var c, connections, id, matchingNode, n, nodes, otherNode, segment, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    connections = [];
    _ref = this.board.components;
    for (id in _ref) {
      c = _ref[id];
      if (!(exceptInSection != null ? exceptInSection.components[id] : void 0)) {
        _ref1 = (nodes = c.currentNodes());
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          n = _ref1[_i];
          matchingNode = this.board.boardPosition(n);
          if (!this.compareNodes(matchingNode, node)) {
            continue;
          }
          if (nodes.length === 1) {
            return [
              {
                component: c,
                otherNode: matchingNode,
                node: node
              }
            ];
          } else {
            otherNode = this.board.boardPosition(this.otherNode(nodes, n));
          }
          connections.push({
            component: c,
            otherNode: otherNode,
            node: node
          });
        }
      }
    }
    _ref2 = this.board.wires.find(node);
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      segment = _ref2[_j];
      if (!(exceptInSection != null ? exceptInSection.components[segment.id] : void 0)) {
        connections.push({
          component: segment,
          otherNode: this.otherNode(segment.nodes, node),
          node: node
        });
      }
    }
    return connections;
  };

  Analyzer.prototype.compareNodes = function(node1, node2) {
    return node1.x === node2.x && node1.y === node2.y;
  };

  Analyzer.prototype.recordSection = function(section) {
    var node1Coords, node2Coords, _base, _base1, _name, _name1;
    this.info.sections[section.id] = section;
    node1Coords = "" + section.nodes[0].x + ":" + section.nodes[0].y;
    node2Coords = "" + section.nodes[1].x + ":" + section.nodes[1].y;
    (_base = this.info.node)[_name = "" + node1Coords] || (_base[_name] = {});
    this.info.node["" + node1Coords][section.id] = section;
    (_base1 = this.info.node)[_name1 = "" + node2Coords] || (_base1[_name1] = {});
    return this.info.node["" + node2Coords][section.id] = section;
  };

  Analyzer.prototype.deleteSection = function(section) {
    delete this.info.sections[section.id];
    delete this.info.node["" + section.nodes[0].x + ":" + section.nodes[0].y][section.id];
    return delete this.info.node["" + section.nodes[1].x + ":" + section.nodes[1].y][section.id];
  };

  Analyzer.prototype.otherNode = function(nodes, node) {
    var n;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        if (!this.compareNodes(n, node)) {
          _results.push(n);
        }
      }
      return _results;
    }).call(this))[0];
  };

  Analyzer.prototype.boardNodes = function(component) {
    var nodes,
      _this = this;
    if (nodes = typeof component.currentNodes === "function" ? component.currentNodes() : void 0) {
      return nodes.map(function(node) {
        return _this.board.boardPosition(node);
      });
    } else {
      return component.nodes;
    }
  };

  Analyzer.prototype.addToMatrixLoop = function(section, direction) {
    var cid;
    if (!this.info.matrix.currentLoop.start) {
      this.info.matrix.currentLoop.start = section.id;
    }
    this.info.matrix.currentLoop.sections[section.id] = {
      resistance: section.resistance * direction * -1
    };
    if (section.voltage) {
      this.info.matrix.currentLoop.voltage += section.voltage * direction;
    }
    if (this.compareNodes.apply(this, section.nodes)) {
      this.completeMatrixLoop();
    }
    this.board.color((function() {
      var _results;
      _results = [];
      for (cid in section.components) {
        _results.push(cid);
      }
      return _results;
    })(), 1);
    console.log('add to loop', this.info.matrix.totalLoops, direction, this.info.matrix.currentLoop.voltage, section.resistance * direction * -1);
    debugger;
  };

  Analyzer.prototype.initMatrix = function() {
    this.info.matrix.loops = {};
    this.info.matrix.sections = [];
    return this.info.matrix.totalLoops = 0;
  };

  Analyzer.prototype.addMatrixLoop = function() {
    return this.info.matrix.currentLoop = {
      voltage: 0,
      sections: {}
    };
  };

  Analyzer.prototype.completeMatrixLoop = function(loopInfo) {
    var sid;
    if (loopInfo == null) {
      loopInfo = this.info.matrix.currentLoop;
    }
    loopInfo.completed = true;
    for (sid in loopInfo.sections) {
      if (this.info.matrix.sections.indexOf(sid) === -1) {
        this.info.matrix.sections.push(sid);
      }
    }
    this.info.matrix.totalLoops += 1;
    return this.info.matrix.loops[this.info.matrix.totalLoops] = loopInfo;
  };

  Analyzer.prototype.matrixLoopDirection = function(section, startingNode) {
    var direction, nodeAligned;
    nodeAligned = this.compareNodes(section.nodes[0], startingNode);
    if ((nodeAligned && section.direction === 1) || (!nodeAligned && section.direction === -1)) {
      return direction = 1;
    } else {
      return direction = -1;
    }
  };

  Analyzer.prototype.addMatrixIndentityLoop = function(node, sections) {
    var identityLoop, section, sid;
    identityLoop = {
      voltage: 0,
      sections: {}
    };
    for (sid in sections) {
      section = sections[sid];
      identityLoop.sections[sid] = {
        resistance: this.matrixLoopDirection(section, node)
      };
    }
    return this.completeMatrixLoop(identityLoop);
  };

  Analyzer.prototype.createMatrix = function() {
    var allSections, direction, lastSection, nextNode, nextSection, nextSections, section, sid;
    this.initMatrix();
    allSections = {};
    for (sid in this.info.sections) {
      allSections[sid] = true;
    }
    this.addMatrixLoop();
    nextSection = this.info.sections[Object.keys(allSections)[0]];
    this.addToMatrixLoop(nextSection, 1);
    delete allSections[nextSection.id];
    nextNode = nextSection.nodes[1];
    while (Object.keys(allSections).length || !this.info.matrix.currentLoop.completed) {
      lastSection = nextSection;
      nextSection = null;
      nextSections = this.info.node["" + nextNode.x + ":" + nextNode.y];
      if (Object.keys(nextSections).length > 2) {
        this.addMatrixIndentityLoop(nextNode, nextSections);
      }
      for (sid in nextSections) {
        section = nextSections[sid];
        if (!(sid !== lastSection.id && sid === this.info.matrix.currentLoop.start)) {
          continue;
        }
        nextSection = section;
        break;
      }
      if (!nextSection) {
        for (sid in nextSections) {
          section = nextSections[sid];
          if (!allSections[sid]) {
            continue;
          }
          nextSection = section;
          direction = this.matrixLoopDirection(section, nextNode);
          if (direction === 1) {
            break;
          }
        }
      }
      if (!nextSection) {
        for (sid in nextSections) {
          section = nextSections[sid];
          if (!(!this.info.matrix.currentLoop.sections[sid])) {
            continue;
          }
          nextSection = section;
          direction = this.matrixLoopDirection(section, nextNode);
          if (direction === 1) {
            break;
          }
        }
      }
      if (nextSection && nextSection.id === this.info.matrix.currentLoop.start) {
        this.completeMatrixLoop();
      }
      if (!nextSection || this.info.matrix.currentLoop.completed) {
        if (!Object.keys(allSections).length) {
          return;
        }
        this.addMatrixLoop();
        nextSection = this.info.sections[((function() {
          var _results;
          _results = [];
          for (sid in allSections) {
            _results.push(sid);
          }
          return _results;
        })())[0]];
        direction = 1;
        nextNode = nextSection.nodes[0];
      }
      this.addToMatrixLoop(nextSection, direction);
      delete allSections[nextSection.id];
      nextNode = this.otherNode(nextSection.nodes, nextNode);
    }
  };

  Analyzer.prototype.fillOutMatrix = function() {
    var index, index2, loopInfo, loopInfo2, sectionId, _ref, _results;
    _ref = this.info.matrix.loops;
    _results = [];
    for (index in _ref) {
      loopInfo = _ref[index];
      loopInfo.adjustedVoltage = loopInfo.voltage;
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (sectionId in loopInfo.sections) {
          loopInfo.sections[sectionId].adjusted = loopInfo.sections[sectionId].resistance;
          _results1.push((function() {
            var _base, _ref1, _results2;
            _ref1 = this.info.matrix.loops;
            _results2 = [];
            for (index2 in _ref1) {
              loopInfo2 = _ref1[index2];
              if (index2 !== index) {
                _results2.push((_base = loopInfo2.sections)[sectionId] || (_base[sectionId] = {
                  resistance: 0,
                  adjusted: 0
                }));
              }
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Analyzer.prototype.reduceMatrix = function() {
    var adjustingLoop, adjustingSection, adjustingSectionId, adjustingVariableIndex, adjustingfactor, debugLoopIndex, factor, factorLoop, factorLoopIndex, loopIndex, sectionId, sectionIds, sid, testIndex, testSectionId, tested, variableIndex, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref, _ref1, _ref2, _ref3, _results;
    sectionIds = this.info.matrix.sections;
    for (debugLoopIndex = _i = 1, _ref = this.info.matrix.totalLoops; 1 <= _ref ? _i <= _ref : _i >= _ref; debugLoopIndex = 1 <= _ref ? ++_i : --_i) {
      console.log(((function() {
        var _j, _len, _results;
        _results = [];
        for (_j = 0, _len = sectionIds.length; _j < _len; _j++) {
          sid = sectionIds[_j];
          _results.push(this.info.matrix.loops[debugLoopIndex].sections[sid].adjusted);
        }
        return _results;
      }).call(this)).join(' | '), this.info.matrix.loops[debugLoopIndex].adjustedVoltage);
    }
    console.log('');
    _results = [];
    for (variableIndex = _j = 0, _len = sectionIds.length; _j < _len; variableIndex = ++_j) {
      sectionId = sectionIds[variableIndex];
      _ref1 = this.info.matrix.loops;
      for (factorLoopIndex in _ref1) {
        factorLoop = _ref1[factorLoopIndex];
        tested = true;
        for (testIndex = _k = 0, _len1 = sectionIds.length; _k < _len1; testIndex = ++_k) {
          testSectionId = sectionIds[testIndex];
          if (testIndex < variableIndex) {
            if (factorLoop.sections[testSectionId].adjusted > 0) {
              tested = false;
              break;
            }
          }
        }
        if (!(factorLoop.sections[sectionId].adjusted > 0)) {
          tested = false;
        }
        if (tested) {
          break;
        }
      }
      factor = factorLoop.sections[sectionId].adjusted;
      if (!factor) {
        continue;
      }
      console.log(factorLoopIndex, factor);
      for (loopIndex = _l = 1, _ref2 = this.info.matrix.totalLoops; 1 <= _ref2 ? _l <= _ref2 : _l >= _ref2; loopIndex = 1 <= _ref2 ? ++_l : --_l) {
        if (!(("" + loopIndex) !== ("" + factorLoopIndex))) {
          continue;
        }
        adjustingLoop = this.info.matrix.loops[loopIndex];
        adjustingfactor = adjustingLoop.sections[sectionId].adjusted;
        for (adjustingVariableIndex = _m = 0, _len2 = sectionIds.length; _m < _len2; adjustingVariableIndex = ++_m) {
          adjustingSectionId = sectionIds[adjustingVariableIndex];
          adjustingSection = adjustingLoop.sections[adjustingSectionId];
          adjustingSection.adjusted = adjustingSection.adjusted - (factorLoop.sections[adjustingSectionId].adjusted * (adjustingfactor / factor));
        }
        adjustingLoop.adjustedVoltage = adjustingLoop.adjustedVoltage - (factorLoop.adjustedVoltage * (adjustingfactor / factor));
      }
      for (debugLoopIndex = _n = 1, _ref3 = this.info.matrix.totalLoops; 1 <= _ref3 ? _n <= _ref3 : _n >= _ref3; debugLoopIndex = 1 <= _ref3 ? ++_n : --_n) {
        console.log(((function() {
          var _len3, _o, _results1;
          _results1 = [];
          for (_o = 0, _len3 = sectionIds.length; _o < _len3; _o++) {
            sid = sectionIds[_o];
            _results1.push(this.info.matrix.loops[debugLoopIndex].sections[sid].adjusted);
          }
          return _results1;
        }).call(this)).join(' | '), this.info.matrix.loops[debugLoopIndex].adjustedVoltage);
      }
      _results.push(console.log(''));
    }
    return _results;
  };

  Analyzer.prototype.assignAmps = function() {
    var amps, index, loopIndex, loopInfo, loopInfoIndex, sectionId, settingLoop, _i, _len, _ref, _ref1, _results;
    _ref = this.info.matrix.sections;
    _results = [];
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      sectionId = _ref[index];
      _ref1 = this.info.matrix.loops;
      for (loopInfoIndex in _ref1) {
        loopInfo = _ref1[loopInfoIndex];
        if (loopInfo.sections[sectionId].adjusted !== 0) {
          break;
        }
      }
      amps = Math.round(100.0 * (loopInfo.adjustedVoltage / loopInfo.sections[sectionId].adjusted)) / 100.0;
      console.log(index + 1, amps);
      _results.push((function() {
        var _ref2, _results1;
        _ref2 = this.info.matrix.loops;
        _results1 = [];
        for (loopIndex in _ref2) {
          settingLoop = _ref2[loopIndex];
          _results1.push(settingLoop.sections[sectionId].amps = amps);
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Analyzer.prototype.solveMatrix = function() {
    this.fillOutMatrix();
    this.reduceMatrix();
    return this.assignAmps();
  };

  return Analyzer;

})(circuitousObject.Object);

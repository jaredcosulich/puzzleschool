// Generated by CoffeeScript 1.3.3
var analyzer, circuitousObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

analyzer = typeof exports !== "undefined" && exports !== null ? exports : provide('./analyzer', {});

circuitousObject = require('./object');

analyzer.Analyzer = (function(_super) {

  __extends(Analyzer, _super);

  function Analyzer(board) {
    this.board = board;
    this.init();
  }

  Analyzer.prototype.init = function() {
    return this.info = {
      matrix: {},
      node: {},
      nodes: {},
      sections: {},
      components: {}
    };
  };

  Analyzer.prototype.run = function() {
    this.analyze();
    this.createMatrix();
    return console.log(this.info.matrix);
  };

  Analyzer.prototype.analyze = function() {
    var cid, component, node, positiveTerminal, _ref, _results;
    _ref = this.board.components;
    _results = [];
    for (cid in _ref) {
      component = _ref[cid];
      if (!component.powerSource) {
        continue;
      }
      if (this.info.components[cid]) {
        continue;
      }
      _results.push((function() {
        var _i, _len, _ref1, _results1;
        _ref1 = component.currentNodes('positive');
        _results1 = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          positiveTerminal = _ref1[_i];
          node = this.board.boardPosition(positiveTerminal);
          _results1.push(this.createSection(component, node));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Analyzer.prototype.newSection = function(node) {
    var section;
    section = {
      nodes: [node],
      resistance: 0,
      components: {},
      sections: {},
      id: this.generateId('section')
    };
    return section;
  };

  Analyzer.prototype.createSection = function(component, node) {
    var c, connections, section, _i, _len;
    section = this.newSection(node);
    connections = this.analyzeSection(section, component, this.otherNode(this.boardNodes(component), node));
    if ((connections != null ? connections.length : void 0) > 1) {
      for (_i = 0, _len = connections.length; _i < _len; _i++) {
        c = connections[_i];
        this.createSection(c.component, c.node);
      }
    }
    return this.endSection(section);
  };

  Analyzer.prototype.analyzeSection = function(section, component, node) {
    var connection, connections;
    if (this.addToSection(section, component, node)) {
      connections = this.findConnections(node, section);
      if (connections.length === 1) {
        connection = connections[0];
        return this.analyzeSection(section, connection.component, connection.otherNode);
      } else if (connections.length > 1) {
        return connections;
      }
    }
  };

  Analyzer.prototype.addToSection = function(section, component, node) {
    var voltage;
    if (this.info.components[component.id]) {
      return false;
    }
    if (component.powerSource) {
      section.direction = (node.negative ? 1 : -1);
      voltage = component.voltage * component.direction;
      section.voltage = (section.voltage || 0) + voltage;
      section.powerSource = true;
      section.negativeComponentId = component.negativeComponentId || component.id;
    }
    section.resistance += component.resistance || 0;
    section.components[component.id] = true;
    section.nodes[1] = node;
    this.info.components[component.id] = section.id;
    return true;
  };

  Analyzer.prototype.endSection = function(section) {
    if (!Object.keys(section.components).length) {
      return;
    }
    if (!section.direction) {
      section.direction = 1;
    }
    return this.recordSection(section, component);
  };

  Analyzer.prototype.findConnections = function(node, exceptInSection) {
    var c, connections, id, matchingNode, n, nodes, otherNode, segment, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    connections = [];
    _ref = this.board.components;
    for (id in _ref) {
      c = _ref[id];
      if (!(exceptInSection != null ? exceptInSection.components[id] : void 0)) {
        _ref1 = (nodes = c.currentNodes());
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          n = _ref1[_i];
          matchingNode = this.board.boardPosition(n);
          if (!this.compareNodes(matchingNode, node)) {
            continue;
          }
          if (nodes.length === 1) {
            return [
              {
                component: c,
                otherNode: matchingNode,
                node: node
              }
            ];
          } else {
            otherNode = this.board.boardPosition(this.otherNode(nodes, n));
          }
          connections.push({
            component: c,
            otherNode: otherNode,
            node: node
          });
        }
      }
    }
    _ref2 = this.board.wires.find(node);
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      segment = _ref2[_j];
      if (!(exceptInSection != null ? exceptInSection.components[segment.id] : void 0)) {
        connections.push({
          component: segment,
          otherNode: this.otherNode(segment.nodes, node),
          node: node
        });
      }
    }
    return connections;
  };

  Analyzer.prototype.compareNodes = function(node1, node2) {
    return node1.x === node2.x && node1.y === node2.y;
  };

  Analyzer.prototype.recordSection = function(section, children) {
    var child, node1Coords, node2Coords, _base, _base1, _base2, _base3, _i, _len, _name, _name1, _name2, _name3;
    if (children) {
      if (!/Array/.test(children.constructor)) {
        children = [children];
      }
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        child.parentId = section.id;
        section.sections[child.id] = true;
      }
    }
    this.info.sections[section.id] = section;
    node1Coords = "" + section.nodes[0].x + ":" + section.nodes[0].y;
    node2Coords = "" + section.nodes[1].x + ":" + section.nodes[1].y;
    (_base = this.info.node)[_name = "" + node1Coords] || (_base[_name] = {});
    this.info.node["" + node1Coords][section.id] = section;
    (_base1 = this.info.node)[_name1 = "" + node2Coords] || (_base1[_name1] = {});
    this.info.node["" + node2Coords][section.id] = section;
    (_base2 = this.info.nodes)[_name2 = "" + node1Coords + node2Coords] || (_base2[_name2] = {});
    this.info.nodes["" + node1Coords + node2Coords][section.id] = section;
    (_base3 = this.info.nodes)[_name3 = "" + node2Coords + node1Coords] || (_base3[_name3] = {});
    return this.info.nodes["" + node2Coords + node1Coords][section.id] = section;
  };

  Analyzer.prototype.otherNode = function(nodes, node) {
    var n;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        if (!this.compareNodes(n, node)) {
          _results.push(n);
        }
      }
      return _results;
    }).call(this))[0];
  };

  Analyzer.prototype.boardNodes = function(component) {
    var nodes,
      _this = this;
    if (nodes = typeof component.currentNodes === "function" ? component.currentNodes() : void 0) {
      return nodes.map(function(node) {
        return _this.board.boardPosition(node);
      });
    } else {
      return component.nodes;
    }
  };

  Analyzer.prototype.addToMatrixLoop = function(section, direction) {
    if (!this.currentMatrixLoop().start) {
      this.currentMatrixLoop().start = section.id;
    }
    this.currentMatrixLoop()[section.id] = {
      resistance: section.resistance * direction
    };
    if (section.voltage) {
      return this.currentMatrixLoop().voltage += section.voltage * direction;
    }
  };

  Analyzer.prototype.addMatrixLoop = function() {
    var _base;
    this.board.clearColors();
    (_base = this.info.matrix).currentLoop || (_base.currentLoop = 0);
    this.info.matrix.currentLoop += 1;
    return this.info.matrix[this.info.matrix.currentLoop] = {
      voltage: 0
    };
  };

  Analyzer.prototype.currentMatrixLoop = function() {
    return this.info.matrix[this.info.matrix.currentLoop];
  };

  Analyzer.prototype.matrixLoopDirection = function(section, startingNode) {
    var direction, nodeAligned;
    nodeAligned = this.compareNodes(section.nodes[0], startingNode);
    if ((nodeAligned && section.direction === 1) || (!nodeAligned && section.direction === -1)) {
      direction = 1;
    } else {
      direction = -1;
    }
    return direction;
  };

  Analyzer.prototype.createMatrix = function() {
    var allSections, direction, lastSection, nextNode, nextSection, nextSections, section, sid;
    allSections = {};
    for (sid in this.info.sections) {
      allSections[sid] = true;
    }
    this.addMatrixLoop();
    nextSection = this.info.sections[Object.keys(allSections)[0]];
    this.addToMatrixLoop(nextSection, 1);
    delete allSections[nextSection.id];
    nextNode = nextSection.nodes[1];
    while (Object.keys(allSections).length || !this.currentMatrixLoop().completed) {
      lastSection = nextSection;
      nextSection = null;
      nextSections = this.info.node["" + nextNode.x + ":" + nextNode.y];
      for (sid in nextSections) {
        section = nextSections[sid];
        if (!(sid !== lastSection.id && sid === this.currentMatrixLoop().start)) {
          continue;
        }
        nextSection = section;
        break;
      }
      if (!nextSection) {
        for (sid in nextSections) {
          section = nextSections[sid];
          if (!allSections[sid]) {
            continue;
          }
          nextSection = section;
          direction = this.matrixLoopDirection(section, nextNode);
          if (direction === 1) {
            break;
          }
        }
      }
      if (!nextSection) {
        for (sid in nextSections) {
          section = nextSections[sid];
          if (!(!this.currentMatrixLoop()[sid])) {
            continue;
          }
          nextSection = section;
          direction = this.matrixLoopDirection(section, nextNode);
          if (direction === 1) {
            break;
          }
        }
      }
      this.currentMatrixLoop().completed = nextSection.id === this.currentMatrixLoop().start;
      if (!nextSection || this.currentMatrixLoop().completed) {
        if (!Object.keys(allSections).length) {
          return;
        }
        this.addMatrixLoop();
        nextSection = this.info.sections[((function() {
          var _results;
          _results = [];
          for (sid in allSections) {
            _results.push(sid);
          }
          return _results;
        })())[0]];
        direction = 1;
        nextNode = nextSection.nodes[0];
      }
      this.addToMatrixLoop(nextSection, direction);
      delete allSections[nextSection.id];
      nextNode = this.otherNode(nextSection.nodes, nextNode);
    }
  };

  return Analyzer;

})(circuitousObject.Object);

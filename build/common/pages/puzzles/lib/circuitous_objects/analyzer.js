// Generated by CoffeeScript 1.3.3
var analyzer, circuitousObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

analyzer = typeof exports !== "undefined" && exports !== null ? exports : provide('./analyzer', {});

circuitousObject = require('./object');

analyzer.Analyzer = (function(_super) {

  __extends(Analyzer, _super);

  function Analyzer(board) {
    this.board = board;
    this.init();
  }

  Analyzer.prototype.init = function() {
    return this.info = {
      node: {},
      nodes: {},
      sections: {},
      components: {}
    };
  };

  Analyzer.prototype.run = function() {
    return this.reduceSections();
  };

  Analyzer.prototype.initLevel = function(level) {
    this.info.node[level] = {};
    this.info.nodes[level] = {};
    this.info.sections[level] = {};
    return this.info.components[level] = {};
  };

  Analyzer.prototype.compareNodes = function(node1, node2) {
    return node1.x === node2.x && node1.y === node2.y;
  };

  Analyzer.prototype.reduceSections = function(level) {
    var component, id, negativeTerminal, _i, _len, _ref, _ref1;
    if (level == null) {
      level = 1;
    }
    this.initLevel(level);
    _ref = this.board.components;
    for (id in _ref) {
      component = _ref[id];
      if (component.powerSource) {
        _ref1 = component.currentNodes('negative');
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          negativeTerminal = _ref1[_i];
          this.combineSections(level, this.board.boardPosition(negativeTerminal), component);
        }
      }
    }
    level += 1;
    this.initLevel(level);
    if (this.reduceParallels(level)) {
      return this.reduceSections(level);
    }
  };

  Analyzer.prototype.reduceParallels = function(level) {
    var componentIds, id, nodeIds, parallel, reductionFound, resistance, section, sections, _ref;
    reductionFound = false;
    _ref = this.info.nodes[level - 1];
    for (nodeIds in _ref) {
      sections = _ref[nodeIds];
      if (!(Object.keys(sections).length > 1 && !sections.parallel)) {
        continue;
      }
      reductionFound = true;
      resistance = 0;
      for (id in sections) {
        section = sections[id];
        resistance += 1.0 / section.resistance;
      }
      parallel = {
        id: this.generateId(),
        resistance: 1.0 / resistance,
        nodes: section.nodes
      };
      this.info.node[level]["" + section.nodes[0].x + ":" + section.nodes[0].y][parallel.id] = parallel;
      this.info.node[level]["" + section.nodes[1].x + ":" + section.nodes[1].y][parallel.id] = parallel;
      this.board.clearColors();
      componentIds = [];
      for (id in sections) {
        section = sections[id];
        componentIds = componentIds.concat((function() {
          var _results;
          _results = [];
          for (id in section.components) {
            _results.push(id);
          }
          return _results;
        })());
      }
      this.board.color(componentIds, 0);
      debugger;
    }
    if (reductionFound) {
      this.reduceParallels();
    }
    return reductionFound;
  };

  Analyzer.prototype.combineSections = function(level, node, component, section) {
    var connection, connections, parallelSection, _i, _len, _results;
    if (section == null) {
      section = this.newSection(node);
    }
    if (this.addToSection(level, section, node, component)) {
      if ((connections = this.findConnections(level, node, component, section)).length === 1) {
        connection = connections[0];
        if (section.components[connection.component.id]) {
          return this.endSection(level, section, connection.matchingNode, connection.component);
        } else {
          return this.combineSections(level, connection.otherNode, connection.component, section);
        }
      } else if (connections.length > 1) {
        this.endSection(level, section, node, component);
        _results = [];
        for (_i = 0, _len = connections.length; _i < _len; _i++) {
          connection = connections[_i];
          _results.push(parallelSection = this.combineSections(level, connection.otherNode, connection.component));
        }
        return _results;
      }
    } else {
      return this.endSection(level, section, node, component);
    }
  };

  Analyzer.prototype.findConnections = function(level, node, component, circuit) {
    var c, connection, connections, existingConnections, id, matchingNode, n, nodes, otherNode, segment, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    connections = [];
    if (level > 1) {
      existingConnections = this.info.node[level - 1]["" + node.x + ":" + node.y];
      if (existingConnections && (Object.keys(existingConnections).length === 1 || existingConnections.parallel)) {
        connection = existingConnections.parallel;
        if (!connection) {
          connection = existingConnections[0];
        }
        otherNode = ((function() {
          var _i, _len, _ref, _results;
          _ref = connection.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            otherNode = _ref[_i];
            if (!this.compareNodes(node, otherNode)) {
              _results.push(otherNode);
            }
          }
          return _results;
        }).call(this))[0];
        return [
          {
            component: connection,
            node: node,
            otherNode: otherNode
          }
        ];
      }
    } else {
      _ref = this.board.components;
      for (id in _ref) {
        c = _ref[id];
        if (c !== component && (id === circuit.negativeComponentId || !circuit.components[id])) {
          _ref1 = (nodes = c.currentNodes());
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            n = _ref1[_i];
            matchingNode = this.board.boardPosition(n);
            if (!this.compareNodes(matchingNode, node)) {
              continue;
            }
            if (nodes.length === 1) {
              return [
                {
                  component: c,
                  matchingNode: matchingNode,
                  otherNode: matchingNode
                }
              ];
            } else {
              otherNode = ((function() {
                var _j, _len1, _results;
                _results = [];
                for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
                  otherNode = nodes[_j];
                  if (!this.compareNodes(matchingNode, otherNode)) {
                    _results.push(otherNode);
                  }
                }
                return _results;
              }).call(this))[0];
            }
            connections.push({
              component: c,
              matchingNode: matchingNode,
              otherNode: this.board.boardPosition(otherNode)
            });
          }
        }
      }
      _ref2 = this.board.wires.find(node);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        segment = _ref2[_j];
        if (!(!circuit.components[segment.id])) {
          continue;
        }
        matchingNode = ((function() {
          var _k, _len2, _ref3, _results;
          _ref3 = segment.nodes;
          _results = [];
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            n = _ref3[_k];
            if (this.compareNodes(n, node)) {
              _results.push(n);
            }
          }
          return _results;
        }).call(this))[0];
        otherNode = ((function() {
          var _k, _len2, _ref3, _results;
          _ref3 = segment.nodes;
          _results = [];
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            n = _ref3[_k];
            if (!this.compareNodes(n, node)) {
              _results.push(n);
            }
          }
          return _results;
        }).call(this))[0];
        connections.push({
          component: segment,
          matchingNode: matchingNode,
          otherNode: otherNode
        });
      }
    }
    return connections;
  };

  Analyzer.prototype.newSection = function(node) {
    var section;
    section = {
      nodes: [node],
      resistance: 0,
      components: {},
      id: this.generateId()
    };
    return section;
  };

  Analyzer.prototype.addToSection = function(level, section, node, component) {
    if (this.info.components[level][component.id]) {
      return false;
    }
    if (component.powerSource && node.negative) {
      section.negativeComponentId = component.id;
    }
    section.resistance += component.resistance || 0;
    section.components[component.id] = true;
    if (!component.powerSource) {
      this.info.components[level][component.id] = section.id;
    }
    return true;
  };

  Analyzer.prototype.endSection = function(level, section, node, component) {
    var id, node1Coords, node2Coords, _base, _base1, _base2, _base3, _name, _name1, _name2, _name3;
    if (component.powerSource && node.positive) {
      section.positiveComponent = component;
    }
    section.nodes.push(node);
    node1Coords = "" + section.nodes[0].x + ":" + section.nodes[0].y;
    node2Coords = "" + section.nodes[1].x + ":" + section.nodes[1].y;
    this.info.sections[level][section.id] = section;
    (_base = this.info.node[level])[_name = "" + node1Coords] || (_base[_name] = {});
    this.info.node[level]["" + node1Coords][section.id] = section;
    (_base1 = this.info.node[level])[_name1 = "" + node2Coords] || (_base1[_name1] = {});
    this.info.node[level]["" + node2Coords][section.id] = section;
    (_base2 = this.info.nodes[level])[_name2 = "" + node1Coords + node2Coords] || (_base2[_name2] = {});
    this.info.nodes[level]["" + node1Coords + node2Coords][section.id] = section;
    (_base3 = this.info.nodes[level])[_name3 = "" + node2Coords + node1Coords] || (_base3[_name3] = {});
    this.info.nodes[level]["" + node2Coords + node1Coords][section.id] = section;
    return this.board.color((function() {
      var _results;
      _results = [];
      for (id in section.components) {
        _results.push(id);
      }
      return _results;
    })(), Object.keys(this.info.sections).length - 1);
  };

  return Analyzer;

})(circuitousObject.Object);

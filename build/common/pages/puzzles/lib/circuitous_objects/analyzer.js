// Generated by CoffeeScript 1.3.3
var analyzer, circuitousObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

analyzer = typeof exports !== "undefined" && exports !== null ? exports : provide('./analyzer', {});

circuitousObject = require('./object');

analyzer.Analyzer = (function(_super) {

  __extends(Analyzer, _super);

  function Analyzer(board) {
    this.board = board;
    this.init();
  }

  Analyzer.prototype.init = function() {
    return this.info = {
      node: {},
      nodes: {},
      sections: {},
      components: {}
    };
  };

  Analyzer.prototype.run = function() {
    this.initLevel(1);
    return this.reduceSections(1);
  };

  Analyzer.prototype.initLevel = function(level) {
    this.info.node[level] = {};
    this.info.nodes[level] = {};
    this.info.sections[level] = {};
    return this.info.components[level] = {};
  };

  Analyzer.prototype.compareNodes = function(node1, node2) {
    return node1.x === node2.x && node1.y === node2.y;
  };

  Analyzer.prototype.reduceSections = function(level) {
    var component, id, negativeTerminal, node, _i, _len, _ref, _ref1;
    if (level == null) {
      level = 1;
    }
    this.board.clearColors();
    _ref = this.board.components;
    for (id in _ref) {
      component = _ref[id];
      if (component.powerSource) {
        _ref1 = component.currentNodes('negative');
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          negativeTerminal = _ref1[_i];
          node = this.board.boardPosition(negativeTerminal);
          this.combineSections(level, node, component, this.newSection(node));
        }
      }
    }
    level += 1;
    this.initLevel(level);
    if (this.reduceParallels(level)) {
      return this.reduceSections(level);
    }
  };

  Analyzer.prototype.recordSection = function(level, section) {
    var node1Coords, node2Coords, _base, _base1, _base2, _base3, _name, _name1, _name2, _name3;
    node1Coords = "" + section.nodes[0].x + ":" + section.nodes[0].y;
    node2Coords = "" + section.nodes[1].x + ":" + section.nodes[1].y;
    this.info.sections[level][section.id] = section;
    (_base = this.info.node[level])[_name = "" + node1Coords] || (_base[_name] = {});
    this.info.node[level]["" + node1Coords][section.id] = section;
    (_base1 = this.info.node[level])[_name1 = "" + node2Coords] || (_base1[_name1] = {});
    this.info.node[level]["" + node2Coords][section.id] = section;
    (_base2 = this.info.nodes[level])[_name2 = "" + node1Coords + node2Coords] || (_base2[_name2] = {});
    this.info.nodes[level]["" + node1Coords + node2Coords][section.id] = section;
    (_base3 = this.info.nodes[level])[_name3 = "" + node2Coords + node1Coords] || (_base3[_name3] = {});
    return this.info.nodes[level]["" + node2Coords + node1Coords][section.id] = section;
  };

  Analyzer.prototype.reduceParallels = function(level) {
    var analyzed, cid, componentIds, id, node1Coords, node2Coords, nodeIds, parallel, reductionFound, resistance, section, sections, _ref;
    reductionFound = false;
    analyzed = {};
    _ref = this.info.nodes[level - 1];
    for (nodeIds in _ref) {
      sections = _ref[nodeIds];
      section = sections[Object.keys(sections)[0]];
      node1Coords = "" + section.nodes[0].x + ":" + section.nodes[0].y;
      node2Coords = "" + section.nodes[1].x + ":" + section.nodes[1].y;
      if (analyzed[node1Coords] && analyzed[node2Coords] && analyzed[node1Coords] === analyzed[node2Coords]) {
        continue;
      }
      if (Object.keys(sections).length > 1) {
        reductionFound = true;
        resistance = 0;
        for (id in sections) {
          section = sections[id];
          resistance += 1.0 / section.resistance;
        }
        parallel = {
          id: this.generateId(),
          resistance: 1.0 / resistance,
          components: {},
          nodes: section.nodes
        };
        for (id in sections) {
          section = sections[id];
          for (cid in section.components) {
            parallel.components[cid] = true;
          }
        }
        analyzed[node1Coords] = analyzed[node2Coords] = parallel.id;
        this.recordSection(level, parallel);
        this.board.clearColors();
        componentIds = [];
        for (id in sections) {
          section = sections[id];
          componentIds = componentIds.concat((function() {
            var _results;
            _results = [];
            for (id in section.components) {
              _results.push(id);
            }
            return _results;
          })());
        }
        this.board.color(componentIds, 0);
      } else {
        this.recordSection(level, section);
      }
    }
    if (reductionFound) {
      this.reduceParallels();
    }
    return reductionFound;
  };

  Analyzer.prototype.combineSections = function(level, node, component, section) {
    var connection, connections, id, parallelSection, _i, _len, _results;
    if (level > 1 && component.components) {
      this.board.color((function() {
        var _results;
        _results = [];
        for (id in component.components) {
          _results.push(id);
        }
        return _results;
      })(), 1);
    }
    if (this.addToSection(level, section, node, component)) {
      if ((connections = this.findConnections(level, node, component, section)).length === 1) {
        connection = connections[0];
        if (section.components[connection.component.id]) {
          return this.endSection(level, section, node, connection.component);
        } else {
          return this.combineSections(level, connection.otherNode, connection.component, section);
        }
      } else if (connections.length > 1) {
        this.endSection(level, section, node, component);
        _results = [];
        for (_i = 0, _len = connections.length; _i < _len; _i++) {
          connection = connections[_i];
          _results.push(parallelSection = this.combineSections(level, connection.otherNode, connection.component, this.newSection(node)));
        }
        return _results;
      } else {
        return this.endSection(level, section, node, component);
      }
    } else {
      if (Object.keys(section.components).length) {
        return this.endSection(level, section, node, component);
      }
    }
  };

  Analyzer.prototype.findConnections = function(level, node, component, circuit) {
    var c, connection, connections, id, matchingNode, n, nodes, otherNode, segment, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    connections = [];
    if (level > 1) {
      debugger;
      _ref = this.info.node[level]["" + node.x + ":" + node.y];
      for (id in _ref) {
        connection = _ref[id];
        if (!(connection.id !== component.id)) {
          continue;
        }
        otherNode = ((function() {
          var _i, _len, _ref1, _results;
          _ref1 = connection.nodes;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            otherNode = _ref1[_i];
            if (!this.compareNodes(node, otherNode)) {
              _results.push(otherNode);
            }
          }
          return _results;
        }).call(this))[0];
        connections.push({
          component: connection,
          otherNode: otherNode
        });
      }
      return connections;
    } else {
      _ref1 = this.board.components;
      for (id in _ref1) {
        c = _ref1[id];
        if (c !== component && (id === circuit.negativeComponentId || !circuit.components[id])) {
          _ref2 = (nodes = c.currentNodes());
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            n = _ref2[_i];
            matchingNode = this.board.boardPosition(n);
            if (!this.compareNodes(matchingNode, node)) {
              continue;
            }
            if (nodes.length === 1) {
              return [
                {
                  component: c,
                  otherNode: matchingNode
                }
              ];
            } else {
              otherNode = ((function() {
                var _j, _len1, _results;
                _results = [];
                for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
                  otherNode = nodes[_j];
                  if (!this.compareNodes(matchingNode, otherNode)) {
                    _results.push(otherNode);
                  }
                }
                return _results;
              }).call(this))[0];
            }
            connections.push({
              component: c,
              otherNode: this.board.boardPosition(otherNode)
            });
          }
        }
      }
      _ref3 = this.board.wires.find(node);
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        segment = _ref3[_j];
        if (!(!circuit.components[segment.id])) {
          continue;
        }
        otherNode = ((function() {
          var _k, _len2, _ref4, _results;
          _ref4 = segment.nodes;
          _results = [];
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            n = _ref4[_k];
            if (!this.compareNodes(n, node)) {
              _results.push(n);
            }
          }
          return _results;
        }).call(this))[0];
        connections.push({
          component: segment,
          otherNode: otherNode
        });
      }
    }
    return connections;
  };

  Analyzer.prototype.newSection = function(node) {
    var section;
    section = {
      nodes: [node],
      resistance: 0,
      components: {},
      id: this.generateId()
    };
    return section;
  };

  Analyzer.prototype.addToSection = function(level, section, node, component) {
    var cid;
    if (this.info.components[level][component.id]) {
      return false;
    }
    if (component.powerSource && node.negative) {
      section.powerSource = true;
      section.negativeComponentId = component.id;
      section.nodes[0].negative = true;
    }
    section.resistance += component.resistance || 0;
    section.components[component.id] = true;
    for (cid in component.components) {
      section.components[cid] = true;
    }
    if (!component.powerSource) {
      this.info.components[level][component.id] = section.id;
    }
    return true;
  };

  Analyzer.prototype.endSection = function(level, section, node, component, record) {
    var id;
    if (component.powerSource && node.positive) {
      section.powerSource = true;
      section.positiveComponent = component;
    }
    section.nodes.push(node);
    console.log('end section', level, JSON.stringify(section.nodes));
    this.recordSection(level, section);
    this.board.color((function() {
      var _results;
      _results = [];
      for (id in section.components) {
        _results.push(id);
      }
      return _results;
    })(), Object.keys(this.info.sections[level]).length - 1);
    debugger;
  };

  return Analyzer;

})(circuitousObject.Object);

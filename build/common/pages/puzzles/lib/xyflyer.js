// Generated by CoffeeScript 1.3.3
var xyflyer;

xyflyer = typeof exports !== "undefined" && exports !== null ? exports : provide('./lib/xyflyer', {});

xyflyer.ChunkHelper = (function() {

  function ChunkHelper() {}

  return ChunkHelper;

})();

xyflyer.ViewHelper = (function() {

  ViewHelper.prototype.baseFolder = '/assets/images/puzzles/xyflyer/';

  ViewHelper.prototype.maxUnits = 10;

  ViewHelper.prototype.pathContexts = {};

  function ViewHelper(_arg) {
    var backgroundCanvas;
    this.el = _arg.el, backgroundCanvas = _arg.backgroundCanvas, this.grid = _arg.grid;
    this.backgroundCanvas = $(backgroundCanvas);
    if (this.backgroundCanvas && this.backgroundCanvas[0].getContext) {
      this.backgroundContext = this.backgroundCanvas[0].getContext('2d');
    }
    this.initBoard();
  }

  ViewHelper.prototype.$ = function(selector) {
    return $(selector, this.el);
  };

  ViewHelper.prototype.loadImage = function(name, callback) {
    var image,
      _this = this;
    if ((image = this.$(".image_cache .image_" + name + " img")).length) {
      callback(image);
      return;
    }
    image = new Image();
    if (callback) {
      $(image).bind('load', function() {
        return callback(image);
      });
    }
    image.src = "" + this.baseFolder + name + ".png";
    image.className = "image_" + name;
    return this.$('.image_cache').append(image);
  };

  ViewHelper.prototype.initBoard = function() {
    var _this = this;
    this.width = this.backgroundCanvas[0].width = this.backgroundCanvas.width();
    this.height = this.backgroundCanvas[0].height = this.backgroundCanvas.height();
    this.xUnit = this.width / (this.grid.xMax - this.grid.xMin);
    this.yUnit = this.height / (this.grid.yMax - this.grid.yMin);
    this.xAxis = this.width - (this.grid.xMax * this.xUnit);
    this.yAxis = this.height + (this.grid.yMin * this.yUnit);
    this.scale = 1 / (Math.log(Math.sqrt(Math.max(this.grid.xMax - this.grid.xMin, this.grid.yMax - this.grid.yMin))) - 0.5);
    return this.loadImage('island', function(island) {
      var height, width;
      island = $(island);
      height = island.height() * _this.scale;
      width = island.width() * _this.scale;
      _this.backgroundContext.drawImage(island[0], _this.xAxis - (width / 2), _this.yAxis, width, height);
      return _this.drawGrid();
    });
  };

  ViewHelper.prototype.drawGrid = function() {
    var increment, mark, multiple, start, xUnits, yUnits, _i, _j, _ref;
    this.backgroundContext.strokeStyle = 'rgba(255,255,255,0.4)';
    this.backgroundContext.fillStyle = 'rgba(255,255,255,0.4)';
    this.backgroundContext.font = 'normal 12px sans-serif';
    this.backgroundContext.lineWidth = 1;
    this.backgroundContext.beginPath();
    this.backgroundContext.moveTo(this.xAxis, 0);
    this.backgroundContext.lineTo(this.xAxis, this.height);
    this.backgroundContext.moveTo(0, this.yAxis);
    this.backgroundContext.lineTo(this.width, this.yAxis);
    xUnits = this.width / this.xUnit;
    if (xUnits < this.maxUnits) {
      xUnits = this.maxUnits;
    }
    multiple = Math.floor(xUnits / this.maxUnits);
    increment = this.xUnit * multiple;
    start = 0 - (multiple > this.grid.xMin ? (this.grid.xMin * this.xUnit) % increment : increment % (this.grid.xMin * this.xUnit));
    for (mark = _i = start, _ref = this.width; start <= _ref ? _i <= _ref : _i >= _ref; mark = _i += increment) {
      this.backgroundContext.moveTo(mark, this.yAxis + 10);
      this.backgroundContext.lineTo(mark, this.yAxis - 10);
      if (!(mark < 0)) {
        this.backgroundContext.fillText(Math.round(this.grid.xMin + (mark / this.xUnit)), mark + 3, this.yAxis - 3);
      }
    }
    yUnits = this.height / this.yUnit;
    if (yUnits < this.maxUnits) {
      yUnits = this.maxUnits;
    }
    multiple = Math.floor(yUnits / this.maxUnits);
    increment = (this.yUnit * multiple) * -1;
    start = this.height - (multiple > this.grid.yMin ? increment % (this.grid.yMin * this.yUnit) : (this.grid.yMin * this.yUnit) % increment);
    for (mark = _j = start; start <= 0 ? _j <= 0 : _j >= 0; mark = _j += increment) {
      this.backgroundContext.moveTo(this.xAxis + 10, mark);
      this.backgroundContext.lineTo(this.xAxis - 10, mark);
      if (!(mark > this.height)) {
        this.backgroundContext.fillText(Math.round(this.grid.yMax - (mark / this.yUnit)), this.xAxis + 3, mark - 3);
      }
    }
    this.backgroundContext.stroke();
    return this.backgroundContext.closePath();
  };

  ViewHelper.prototype.plot = function(formula, id) {
    var brokenLine, canvas, context, infiniteLine, lastSlope, lastYPos, slope, xPos, yPos, _i, _ref, _ref1;
    context = this.pathContexts[id];
    if (context) {
      context.clearRect(0, 0, this.width, this.height);
    } else {
      canvas = document.createElement('CANVAS');
      canvas.width = this.width;
      canvas.height = this.height;
      this.$('.board').append(canvas);
      context = this.pathContexts[id] = canvas.getContext('2d');
    }
    if (!formula) {
      return;
    }
    context.strokeStyle = 'rgba(0,0,0,0.1)';
    context.lineWidth = 2;
    context.beginPath();
    brokenLine = 0;
    infiniteLine = 0;
    for (xPos = _i = _ref = this.grid.xMin * this.xUnit, _ref1 = this.grid.xMax * this.xUnit; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; xPos = _ref <= _ref1 ? ++_i : --_i) {
      lastYPos = yPos;
      yPos = formula(xPos / this.xUnit) * this.yUnit;
      if (yPos === Number.NEGATIVE_INFINITY) {
        yPos = this.grid.yMin * this.xUnit;
        brokenLine += 1;
      } else if (yPos === Number.POSITIVE_INFINITY) {
        yPos = this.grid.yMax * this.xUnit;
        brokenLine += 1;
      }
      if (lastYPos) {
        lastSlope = slope;
        slope = yPos - lastYPos;
        if (lastSlope && Math.abs(lastSlope - slope) > Math.abs(lastSlope) && Math.abs(lastYPos - yPos) > Math.abs(lastYPos)) {
          context.lineTo(xPos + this.xAxis + 1, (lastSlope > 0 ? 0 : this.height));
          context.moveTo(xPos + this.xAxis + 1, (lastSlope > 0 ? this.height : 0));
          brokenLine += 1;
        }
      }
      if (brokenLine > 0) {
        context.moveTo(xPos + this.xAxis, this.yAxis - yPos);
        brokenLine -= 1;
      } else {
        context.lineTo(xPos + this.xAxis, this.yAxis - yPos);
      }
    }
    context.stroke();
    return context.closePath();
  };

  return ViewHelper;

})();
